Rolle
Du bist Lead Engineer (NestJS + Prisma + Postgres + Expo). Du implementierst end-to-end (DB/API/UI). Keine additive Nebenfeatures; baue die App konsistent nach den Regeln unten.

0) Oberste Produktregeln (hart, ohne Ausnahmen)

Jeder sieht immer alle Tasks (auch Admin) – keine persönlichen Listen.

Jeder kann alles: Jeder User kann jeden Task claimen, jeden Statusübergang ausführen, Gewicht eingeben, entsorgen.

Keine Zuweisung: Tasks werden niemals Usern zugewiesen.

Claim ist nur Kollisionsschutz, kein Besitz. Claim-TTL = 30 Minuten.

Rollen (falls vorhanden) dürfen operativ nichts einschränken. Admin-only gilt nur für Stammdaten/Schedules/Cancel.

Konstanten (hart setzen, nicht konfigurierbar):

ROLE_ENFORCEMENT = "OPEN"
TASK_VISIBILITY = "GLOBAL"
ASSIGNMENT_MODE = "NONE"
CLAIM_TTL_MINUTES = 30

1) Statusmaschine (serverseitig enforced)
OPEN → PICKED_UP → IN_TRANSIT → DROPPED_OFF → TAKEN_OVER → WEIGHED → DISPOSED


CANCELLED nur Admin

weightKg ist Pflicht beim Übergang TAKEN_OVER → WEIGHED

Beim Übergang IN_TRANSIT → DROPPED_OFF: claimedById automatisch auf null setzen (Task wird wieder frei)

2) Datenmodell (Prisma) – zwingend

Task:

status

source enum: SCHEDULED | MANUAL | ADHOC

scheduledFor DateTime?

claimedById String?

claimedAt DateTime?

dedupKey String? @unique (für Scheduling)

Kontext: materialId, standId, stationId, optional hallId, optional boxId, optional targetContainerId

weightKg Int?

AuditEvent:

timestamp (server)

actorUserId

action enum: CLAIM, RELEASE, STATUS_CHANGED, TASK_CREATED, WEIGHT_RECORDED, SCAN, CONTAINER_EMPTIED, ADMIN_EDIT, CANCELLED

entityType, entityId

beforeJson, afterJson, metaJson (taskId/materialId/stationId/hallId/standId/boxId/containerId)

WarehouseContainer:

materialId, capacityKg, isFull, isBlocked, optional currentKg, lastEmptiedAt, notes

TaskSchedule:

ruleType DAILY | WEEKLY | INTERVAL

timeLocal "HH:MM"

timezone "Europe/Berlin"

createDaysAhead default 14

standId (Pflicht), stationId optional

isActive

dedup: SCHED:${scheduleId}:${YYYY-MM-DD}

3) API – zwingend

Sichtbarkeit:

GET /tasks liefert immer alle Tasks (keine Userfilter)

Filter sind Query-only (status/material/station/hall/from/to)

Claim/Release:

POST /tasks/:id/claim (atomar, 409 wenn nicht möglich)

POST /tasks/:id/release (nur Kollisionsschutz aufheben)

Claim TTL berücksichtigen (expired claims können überschrieben werden; schreibe Audit AUTO_RELEASE_EXPIRED)

Transition:

POST /tasks/:id/transition

Prüfe Statusübergang + Pflichtfelder

Keine Rollenprüfung

Wenn task nicht geclaimt oder claim expired: beim Transition automatisch claimen (atomar)

Manuelle Task-Erstellung (Admin-only):

POST /admin/tasks

input: standId, stationId, optional boxId, optional scheduledFor

source=MANUAL, status=OPEN, Audit TASK_CREATED

Scheduling CRUD + Vorschau (Admin-only):

POST /admin/schedules

PATCH /admin/schedules/:id

GET /admin/schedules/preview?days=14

POST /admin/schedules/run (manuell Cron triggern)

Scheduler Job:

läuft stündlich

erzeugt Tasks für next N days pro Schedule, dedup via unique dedupKey

optional policy: AUTO_CANCEL_PREVIOUS scheduled OPEN tasks vom Vortag

Warehouse Container:

GET /warehouse-containers

PATCH /warehouse-containers/:id (capacity, isFull, isBlocked)

POST /warehouse-containers/:id/empty (Admin-only oder offen; entscheide Admin-only)

setzt isFull=false, optional currentKg=0, lastEmptiedAt=now, Audit CONTAINER_EMPTIED

Activity:

GET /activity?from&to&materialId&stationId&hallId&userId&action

GET /tasks/:id/events

Analytics:

GET /analytics/materials?from&to

GET /analytics/stations?from&to

GET /analytics/halls?from&to

GET /analytics/users?from&to (basierend auf AuditEvents + DISPOSED/weightKg)

GET /analytics/lead-times?from&to&by=station|material

GET /analytics/backlog?olderThanHours=...

4) UI – zwingend

Task-Listen (alle sichtbar, niemandem zugeordnet), Kategorien:

Offen (OPEN; scheduledFor heute zuerst)

Unterwegs (PICKED_UP, IN_TRANSIT)

Abgestellt (DROPPED_OFF)

Entsorgung (TAKEN_OVER, WEIGHED)

Abgeschlossen (DISPOSED, CANCELLED)

Geplant (scheduledFor in Zukunft)

Task-Detail:

zeigt Status, Material, Station/Halle, Stand, Box, Zielcontainer

Buttons je nach nächster erlaubter Transition (für alle User gleich)

„Claim“ / „Release“ Buttons (Claim zeigt nur Kollisionsstatus)

Admin:

Schedules (CRUD) + Vorschau nächste 7/14/30 Tage

Manuelle Task-Erstellung

Stammdaten (Material/Station/Stand/Container)

Activity Screen:

sekundengenauer Zeitstempel + Actor + Aktion + Kontext + Filter

Analytics Screen:

Zeitraumfilter + Tabellen/KPIs (echte Daten)

5) Akzeptanzkriterien

Zwei beliebige User sehen identische Tasklisten.

Jeder kann jeden Task übernehmen, abstellen, entsorgen.

Abstellen macht Task wieder frei.

Auto-Tasks werden im Voraus erzeugt + Admin sieht Vorschau der nächsten Tage.

Jede Aktion erzeugt AuditEvent; Activity zeigt alles sekundengenau.

Analytics stimmt mit DISPOSED/weightKg und AuditEvents überein.

Keine Pseudocode-Ausgaben. Vollständiger Code, inkl. Migrations, Seeds, README.